import java.awt.Color;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Scanner;
import java.util.Vector;
import javax.swing.JOptionPane;
import javax.swing.JTable;
import javax.swing.table.DefaultTableModel;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author hp
 */
public class Main extends javax.swing.JFrame {

    /**
     * Creates new form Main
     */
    public Main() {
        initComponents();
        jButton2.setVisible(false);
        jPanel3.setVisible(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jMenu1 = new javax.swing.JMenu();
        jCheckBoxMenuItem1 = new javax.swing.JCheckBoxMenuItem();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jTextField1 = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jTextField2 = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jButton2 = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jPanel2 = new javax.swing.JPanel();
        oldNF = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jLabel5 = new javax.swing.JLabel();
        Reset = new javax.swing.JButton();

        jMenu1.setText("jMenu1");

        jCheckBoxMenuItem1.setSelected(true);
        jCheckBoxMenuItem1.setText("jCheckBoxMenuItem1");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabel1.setText("Enter the Degree of Relation:");

        jLabel2.setText("Enter the number of Functional Dependencies:");

        jTextField2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField2ActionPerformed(evt);
            }
        });

        jButton1.setText("OK");
        jButton1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton1MouseClicked(evt);
            }
        });

        jButton2.setText("Compute...");
        jButton2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButton2MouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jLabel2)
                            .addComponent(jLabel1)))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGap(54, 54, 54)
                        .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 153, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(5, 5, 5)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 99, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(116, Short.MAX_VALUE))
            .addComponent(jScrollPane1)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextField2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(31, 31, 31)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(jLabel3)
                    .addComponent(jButton2))
                .addGap(18, 18, 18)
                .addComponent(jScrollPane1))
        );

        oldNF.setFont(new java.awt.Font("Tahoma", 1, 14)); // NOI18N

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(oldNF, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(oldNF, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(25, Short.MAX_VALUE))
        );

        jLabel5.setFont(new java.awt.Font("Tahoma", 1, 12)); // NOI18N
        jLabel5.setText("Relation(s) & Key(s)");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(176, 176, 176)
                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 131, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(210, Short.MAX_VALUE))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane2))
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addComponent(jLabel5)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 417, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );

        Reset.setText("Reset");
        Reset.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                ResetMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addGap(236, 236, 236)
                        .addComponent(Reset)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(Reset)
                .addGap(18, 18, 18))
        );

        pack();
    }// </editor-fold>                        

    private void jTextField2ActionPerformed(java.awt.event.ActionEvent evt) {                                            
        // TODO add your handling code here:
    }                                           

    private void jButton1MouseClicked(java.awt.event.MouseEvent evt) {                                      
        try{
            jLabel3.setText("");
            String deg = (jTextField1.getText());
            degree = Integer.parseInt(deg);
            String fds = (jTextField2.getText());
            noOfFD = Integer.parseInt(fds);
            takeInput();
                        
        }
        catch(Exception e){
            JOptionPane.showMessageDialog(this, "Invalid Input" + e.getMessage(), "Error!", JOptionPane.ERROR_MESSAGE);
            jLabel3.setForeground(Color.red);
            jLabel3.setText("Incorrect Input");
            jTextField1.setText("");
            jTextField2.setText("");
        }
    }                                     

    private void jButton2MouseClicked(java.awt.event.MouseEvent evt) {                                      
        // TODO add your handling code hereFT
        
        try{
            jPanel3.setVisible(true);
            nReln = new DefaultTableModel();
            nReln.addColumn("Relation");
            nReln.addColumn("Keys");
            newReln = new JTable(nReln);
            jScrollPane2.setViewportView(newReln);
            attrib = new StringBuilder();
            found = new Vector<>();
            keyAttrib = new StringBuilder();
            Scanner inp = new Scanner(System.in);
            System.out.println("Input the " + noOfFD + " Functional dependencies using letters starting from A (Use Capital)");
            System.out.println("Use ' ' (space) to separate the left and right");
            String[] left, right;
            left = new String[noOfFD];
            right = new String[noOfFD]; 
            
            for (int i = 0; i < noOfFD; i++) {
                left[i] = fd.getValueAt(i, 0).toString().toUpperCase();
                right[i] = fd.getValueAt(i, 1).toString().toUpperCase();
                if(left[i].length() == 0 || right[i].length() == 0)
                {
                    throw new Exception();
                }
            }
            
            for (int i = 0; i < noOfFD; i++)
                System.out.println(left[i] + " -> " + right[i]);
            int[] vis = new int[degree];
            for (int i = 0; i < noOfFD; i++)
                for (int j = 0; j < right[i].length(); j++)
                    vis[right[i].charAt(j) - 'A'] = 1;
            for(int i = 0; i < degree; i++)
                attrib.append((char) (i + 'A'));
            StringBuilder partOfCandidateKey = new StringBuilder();
            String finalVis;
            for (int i = 0; i < degree; i++)
                if (vis[i] == 0)
                    partOfCandidateKey.append((char) (i + 'A'));
            finalVis = findPlus(partOfCandidateKey.toString(), left, right);
            if(finalVis.length() == degree) {
                System.out.println("Only 1 Candidate Key Found: " + partOfCandidateKey);
                found.add(partOfCandidateKey.toString());
            }
            else {
                String temp = convertToBinary(partOfCandidateKey.toString(), degree);
                for (int i = 1; i < Math.pow(2, degree - partOfCandidateKey.length()); i++) {
                    String bin;
                    StringBuilder stri = new StringBuilder();
                    bin = convertToBianary(i, degree - partOfCandidateKey.length());
                    int k = 0;
                    for(int j = 0; j < degree; j++) {
                        if (temp.charAt(j) == '0') {
                            stri.append(bin.charAt(k));
                            k++;
                        } else
                            stri.append('1');
                    }
                    findKeys(stri.toString(), degree, left, right);
                }
                System.out.println(found);
            }
            for (String string : found)
                for(int i = 0; i < string.length(); i++)
                    if(!keyAttrib.toString().contains(Character.toString(string.charAt(i))))
                        keyAttrib.append(string.charAt(i));
            checkNF(found, left, right);
            jPanel3.setVisible(true);
        }
        catch(Exception e){
            JOptionPane.showMessageDialog(this, "Invalid Input :" + e.getMessage(), "Error!", JOptionPane.ERROR_MESSAGE);
            
            takeInput();
        }
    }                                     

    private void ResetMouseClicked(java.awt.event.MouseEvent evt) {                                   
        // TODO add your handling code here:
        jButton2.setVisible(false);
        jPanel3.setVisible(false);
        jScrollPane1.setVisible(false);
        jTextField1.setText("");
        jTextField2.setText("");
        jTextField1.setVisible(true);
        jTextField2.setVisible(true);
        jLabel1.setVisible(true);
        jLabel2.setVisible(true);
        jButton1.setVisible(true);
        
    }                                  
    
    static void takeInput(){
        jTextField1.setVisible(false);
        jTextField2.setVisible(false);
        jLabel1.setVisible(false);
        jLabel2.setVisible(false);
        jButton1.setVisible(false);
        jButton2.setVisible(true);     
        fd = new DefaultTableModel();
        fd.addColumn("Left");
        fd.addColumn("Right");
        dirtr = new JTable(fd);
        jScrollPane1.add(dirtr);
        jScrollPane1.setViewportView(dirtr);
        for(int i=0; i < noOfFD; i++){
            fd.addRow(new Object[]{"", ""});
        }
        
    }
    static Vector<String> found = new Vector<>();
    static StringBuilder keyAttrib = new StringBuilder();
    static StringBuilder attrib = new StringBuilder();
    static String convertToBinary(String str, int size){
        char[] s = new char[size];
        for (int i = 0; i < size; i++)
            s[i] = '0';
        for (int i = 0; i < str.length(); i++)
            s[str.charAt(i) - 'A'] = '1';
        return String.valueOf(s);
    }
    static void findKeys(String stri, int degree, String[] left, String[] right) {
        StringBuilder at = new StringBuilder();
        for(int j = 0; j < stri.length(); j++)
            if(stri.charAt(j) == '1')
                at.append((char) (j + 'A'));
        StringBuilder finalAttrib = new StringBuilder();
        for(int l = 0; l < degree; l++)
            finalAttrib.append((char) (l + 'A'));
        if(findPlus(at.toString(), left, right).equals(finalAttrib.toString()))
        {
            boolean isRepeated = false;
            int count;
            for(String string : found) {
                count = 0;
                for (int itr = 0; itr < at.length(); itr++ )
                    if(string.contains(Character.toString(at.charAt(itr))))
                        count++;
                if(count == string.length()) {
                    isRepeated = true;
                    break;
                }
            }
            if(!isRepeated)
                found.add(at.toString());
        }
    }
    static boolean check2NF(Vector<String> found, String[] left, String[] right){
        int temp = 0;
        boolean flag = true;
        for(int i = 0; i < right.length; i++)
            for(int j = 0; j < right[i].length(); j++)
                if(!keyAttrib.toString().contains(right[i].substring(j, j + 1))) {
                    boolean isProperSubset = true;
                    if(found.contains(left[i]))
                        break;
                    for(int k = 0; k < left[i].length(); k++)
                        if(!keyAttrib.toString().contains(left[i].substring(k, k+1))) {
                            isProperSubset = false;
                            break;
                        }
                    if(isProperSubset) {
                        flag = false;
                        if(temp == 0){		                      
                            oldNF.setText("INPUT NF: 1 NF");
                            System.out.println("The Relation is in 1NF");
                            System.out.println("The new relations to get 2NF or higher: ");
                            temp++;
                        }
                        StringBuilder new_reln = new StringBuilder();
                        for (int k = 0; k < right[i].length(); k++) {
                            new_reln.append(right[i].charAt(k));
                            attrib = new StringBuilder(attrib.toString().replace(Character.toString(right[i].charAt(k)), ""));
                        }
                        new_reln.append(left[i]);
                        System.out.print(sortString(new_reln.toString()) + " with keys: ");
                        Vector<String> keys = keyFinder(new_reln, left, right);
                        System.out.println(keys);
                        nReln.addRow(new Object[]{new_reln, keys});
                    }
                    break;
                }
        if(temp != 0) {
            
            Vector<String> keys = keyFinder(attrib,left,right);
            System.out.println(keys);
            nReln.addRow(new Object[]{attrib, keys});
        }
        return flag;
    }
    static boolean check3NF(Vector<String> found, String[] left, String[] right){
        boolean is3NF, flag = true;
        int temp = 0;
        for(int i = 0; i <left.length; i++) {
            is3NF = false;
            for(String st : found) {
                is3NF = true;
                for (int j = 0; j < st.length(); j++)
                    if(!left[i].contains(st.substring(j,j+1))){
                        is3NF = false;
                        break;
                    }
                if(is3NF)
                    break;
            }
            if(!is3NF)
                for(int j = 0; j < right[i].length(); j++) {
                    is3NF = false;
                    for(String st : found)
                        if(st.contains(Character.toString(right[i].charAt(j)))) {
                            is3NF = true;
                            break;
                        }
                    if(!is3NF) {
                        StringBuilder new_reln = new StringBuilder();
                        flag = false;
                        for (int k = 0; k < right[i].length(); k++)
                            if(!keyAttrib.toString().contains(Character.toString(right[i].charAt(k))))
                                new_reln.append(right[i].charAt(k));
                        new_reln.append(left[i]);
                        if(temp == 0){		           
                                    oldNF.setText("INPUT NF: 2 NF");
		                    System.out.println("The Relation is in 2NF");
		                    System.out.println("The new relations to get 3NF or higher: ");
                            temp++;
                        }
                        System.out.println(sortString(new_reln.toString()) + " with keys: ");
                        Vector<String> keys = keyFinder(new_reln, left, right);
                        System.out.println(keys);
                        nReln.addRow(new Object[]{new_reln, keys});
                        new_reln = new StringBuilder();
                        for (int k = 0; k < right[i].length(); k++)
                            if(!keyAttrib.toString().contains(Character.toString(right[i].charAt(k))))
                                new_reln.append(right[i].charAt(k));
                        StringBuilder new_attrib = new StringBuilder();
                        for (int k = 0; k < attrib.length(); k++)
                            if(!new_reln.toString().contains(Character.toString(attrib.charAt(k))))
                                new_attrib.append(attrib.charAt(k));
                        attrib = new StringBuilder(new_attrib.toString());
                        break;
                    }
                }
        }
        if(temp != 0) {
            Vector<Integer> arr = new Vector<>();
            System.out.print(attrib + " with keys: ");
            Vector<String> keys = keyFinder(attrib,left,right);
            System.out.println(keys);
            nReln.addRow(new Object[]{attrib, keys});
        }
        return flag;
    }
    static void checkBCNF(Vector<String> found, String[] left, String[] right){
        boolean isBCNF = false;
        int temp = 0;
        for(int i = 0; i < left.length; i++) {
            for(String st : found) {
                isBCNF = true;
                for (int j = 0; j < st.length(); j++)
                    if(!left[i].contains(st.substring(j,j+1))){
                        isBCNF = false;
                        break;
                    }
                if(isBCNF)
                    break;
            }
            if(!isBCNF) {
                if(temp == 0) {
                    oldNF.setText("INPUT NF: 3 NF");
                    System.out.println("The Relation is in 3NF");
                    System.out.println("The new relations to get BCNF or higher: ");
                    temp ++;
                }
                StringBuilder new_reln = new StringBuilder();
                for(int j = 0; j < right[i].length(); j++)
                    if(!left[i].contains(right[i].substring(j, j + 1)))
                        new_reln.append(right[i].charAt(j));
                new_reln.append(left[i]);
                System.out.println(sortString(new_reln.toString())  + " with keys: ");
                Vector<String> keys = keyFinder(new_reln, left, right);
                System.out.println(keys);
          
                nReln.addRow(new Object[]{new_reln, keys});
                new_reln = new StringBuilder();
                for(int j = 0; j < right[i].length(); j++)
                    if(!left[i].contains(right[i].substring(j, j + 1)))
                        new_reln.append(right[i].charAt(j));
                StringBuilder r = new StringBuilder();
                for(int j = 0; j < attrib.length(); j++)
                    if(!new_reln.toString().contains(attrib.substring(j, j + 1)))
                        r.append(attrib.charAt(j));
                attrib = new StringBuilder(r.toString());
            }
        }
        if(temp == 0){
            oldNF.setText("INPUT NF: BCNF");
            System.out.println("The Relation is in BCNF and the attributes are: ");
        }
        System.out.print(attrib + " with keys: ");
        Vector<String> keys = keyFinder(attrib,left,right);
        System.out.println(keys);
        nReln.addRow(new Object[]{attrib.toString(), keys});
    }
    static void checkNF(Vector<String> found, String[] left, String[] right){
        boolean tf;
        tf = check2NF(found, left, right);
        if(tf){
            System.out.println("2NF: " + tf);
            tf = check3NF(found, left, right);
            if(tf){
	            System.out.println("3NF: " + tf);
                checkBCNF(found, left, right);
            }
        }
    }
    static String convertToBianary(int i, int size) {
        StringBuilder out = new StringBuilder();
        while (i > 0) {
            out.append((i % 2));
            i /= 2;
        }
        out.append("0".repeat(Math.max(0, size - out.length())));
        StringBuilder out2 = new StringBuilder(out.toString());
        return out2.reverse().toString();
    }
    static String sortString(String str) {
        char []arr = str.toCharArray();
        Arrays.sort(arr);
        return String.valueOf(arr);
    }
    static String findPlus(String str, String[] left, String[] right) {
        boolean b;
        boolean c = true;
        StringBuilder strBuilder = new StringBuilder(str);
        while(c){
            c = false;
            for (int j = 0; j < left.length; j++) {
                b = true;
                for (int i = 0; i < left[j].length(); i++) {
                    String temp = "";
                    temp += left[j].charAt(i);
                    if (!strBuilder.toString().contains(temp)) {
                        b = false;
                        break;
                    }
                }
                if(b)
                    for (int i = 0; i < right[j].length(); i++) {
                        String temp = "";
                        temp += right[j].charAt(i);
                        if(!strBuilder.toString().contains(temp)) {
                            strBuilder.append(temp);
                            c = true;
                        }
                    }
            }
        }
        str = strBuilder.toString();
        return sortString(str);
    }
    public static Vector<String> keyFinder(StringBuilder attrib, String[] oldLeft, String[] oldRight){
        Vector<Integer> arr = new Vector<>();
        Vector<String> keys, newKeys;
        String[] left, right;
        StringBuilder newAttrib;
        int k = 0;
        HashMap<Character,Character> hashMap1 = new HashMap<>();
        HashMap<Character,Character> hashMap2 = new HashMap<>();
        for (int i = 0; i < oldLeft.length; i++) {
            for (int j = 0; j < oldLeft[i].length(); j++)
                if(!attrib.toString().contains(oldLeft[i].substring(j,j+1))) {
                    arr.add(i);
                    break;
                }
            for (int j = 0; j < oldRight[i].length(); j++)
                if(!attrib.toString().contains(oldRight[i].substring(j,j+1)) && !arr.contains(i)) {
                    arr.add(i);
                    break;
                }
        }
        left = new String[oldLeft.length - arr.size()];
        right = new String[oldLeft.length - arr.size()];
        for (int i = 0; i < oldLeft.length; i++)
            if(!arr.contains(i)){
                left[k] = oldLeft[i];
                right[k++] = oldRight[i];
            }
        for (int i = 0; i < attrib.length(); i++) {
            hashMap1.put(attrib.charAt(i), (char)(i+'A'));
            hashMap2.put((char)(i+'A'), attrib.charAt(i));
        }
        newAttrib = new StringBuilder(attrib.toString());
        for (int i = 0; i < newAttrib.length(); i++)
            newAttrib.setCharAt(i, hashMap1.get(newAttrib.charAt(i)));
        attrib = new StringBuilder(newAttrib);
        for (int i = 0; i < left.length; i++) {
            StringBuilder temp1 = new StringBuilder(left[i]);
            for (int j = 0; j < left[i].length(); j++)
                temp1.setCharAt(j, hashMap1.get(temp1.charAt(j)));
            left[i] = new String(temp1);
            temp1 = new StringBuilder(right[i]);
            for (int j = 0; j < right[i].length(); j++)
                temp1.setCharAt(j, hashMap1.get(temp1.charAt(j)));
            right[i] = new String(temp1);
        }
        found = new Vector<>();
        int degree = attrib.length();
        int[] vis = new int[degree];
        for (String s : right)
            for (int j = 0; j < s.length(); j++)
                vis[s.charAt(j) - 'A'] = 1;
        StringBuilder partOfCandidateKey = new StringBuilder();
        String finalVis;
        for (int i = 0; i < degree; i++) {
            if (vis[i] == 0) {
                partOfCandidateKey.append((char) (i + 'A'));
            }
        }
        finalVis = findPlus(partOfCandidateKey.toString(), left, right);
        if(finalVis.length() == degree)
            found.add(partOfCandidateKey.toString());
        else {
            String temp = convertToBinary(partOfCandidateKey.toString(), degree);
            for (int i = 1; i < Math.pow(2, degree - partOfCandidateKey.length()); i++) {
                String bin;
                StringBuilder stri = new StringBuilder();
                bin = convertToBianary(i, degree - partOfCandidateKey.length());
                k = 0;
                for(int j = 0; j < degree; j++) {
                    if(temp.charAt(j) == '0') {
                        stri.append(bin.charAt(k));
                        k++;
                    }
                    else
                        stri.append('1');
                }
                findKeys(stri.toString(), degree, left, right);
            }
        }
        newKeys = new Vector<>();
        for (String key : found) {
            StringBuilder temp1 = new StringBuilder(key);
            for (int j = 0; j < key.length(); j++)
                temp1.setCharAt(j, hashMap2.get(temp1.charAt(j)));
            newKeys.add(temp1.toString());
            }
        return newKeys;
    }
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Main.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Main().setVisible(true);
            }
        });
        
        
        
    }
    static int noOfFD, degree;
    public static JTable dirtr ;
    public static DefaultTableModel fd;
    public static javax.swing.JTable newReln;
    public static DefaultTableModel nReln;
    // Variables declaration - do not modify                     
    private javax.swing.JButton Reset;
    private static javax.swing.JButton jButton1;
    private static javax.swing.JButton jButton2;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItem1;
    private static javax.swing.JLabel jLabel1;
    private static javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JMenu jMenu1;
    private static javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private static javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private static javax.swing.JTextField jTextField1;
    private static javax.swing.JTextField jTextField2;
    public static javax.swing.JLabel oldNF;
    // End of variables declaration                   
}
